# name: final

# on:
#   pull_request_target:
#     branches:
#       - main
#     types:
#       - opened
#       - synchronize

# permissions:
#   id-token: write
#   contents: read

# env:
#   CLIENT_ID: da7fd62a-590e-4e7a-8525-55ea01ffb1ac
#   API_BASE: https://sentinel-content-validationapi-prod-bvgsc3hjhyeqangg.canadacentral-01.azurewebsites.net/

# jobs:
#   pr-validate:
#     runs-on: ubuntu-latest

#     steps:
#       - name: Checkout PR code
#         uses: actions/checkout@v3
#         with:
#           token: ${{ secrets.GITHUB_TOKEN }}   # needed when using pull_request_target on forks
#           fetch-depth: 0
#           ref: ${{ github.event.pull_request.head.ref }}
#           repository: ${{ github.event.pull_request.head.repo.full_name }}

#       - name: Get changed JSON files and contents
#         id: prepare_json_files
#         run: |

#           echo "üîç Collecting changed JSON files‚Ä¶"
#           BASE="${{ github.event.pull_request.base.sha }}"
#           HEAD="${{ github.event.pull_request.head.sha }}"

#           mapfile -t files < <(git diff --name-only "$BASE" "$HEAD" | grep -Ei '\.json$')
#           echo "‚Üí All .json files: ${files[*]:-<none>}"

#           # Case-insensitive filter for ‚Äúpoll‚Äù
#           filtered=()
#           for f in "${files[@]}"; do
#             if [[ "$f" =~ [Pp]oll ]]; then
#               filtered+=("$f")
#             fi
#           done

#           if [ ${#filtered[@]} -eq 0 ]; then
#             echo "‚Üí No polling JSON files changed; skipping validation."
#             echo "JSON_PAYLOAD_PATH=empty" >> $GITHUB_ENV
#             exit 0
#           fi

#           echo "‚Üí Polling files: ${filtered[*]}"

#           # Build JSON array payload
#           json_array="["
#           for f in "${filtered[@]}"; do
#             if jq -e . "$f" > /dev/null; then
#               content=$(jq -c . "$f")
#               json_array+="{\"filename\":\"$f\",\"content\":$content},"
#             else
#               echo "‚ùå Invalid JSON in $f"
#               exit 1
#             fi
#           done
#           json_array="${json_array%,}]"
#           echo "$json_array" > files_payload.json
#           echo "JSON_PAYLOAD_PATH=files_payload.json" >> $GITHUB_ENV

#       - name: Request OIDC token from GitHub
#         if: env.JSON_PAYLOAD_PATH != 'empty'
#         id: fetch_token
#         run: |

#           echo "üîê Fetching OIDC token‚Ä¶"
#           raw=$(curl -s \
#             -H "Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
#             "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=api://${CLIENT_ID}")
#           token=$(echo "$raw" | jq -r .value)
#           echo "‚úîÔ∏è Got token (length=${#token})"
#           echo "TOKEN=$token" >> $GITHUB_ENV


#       - name: üì° Health-check GET
#         if: env.JSON_PAYLOAD_PATH != 'empty'
#         run: |

#           echo "üöÄ Hitting $API_BASE‚Ä¶"
#           # Capture both body and status
#           resp=$(curl -s -w "\n%{http_code}" \
#             -H "Authorization: Bearer $TOKEN" \
#             "$API_BASE")
#           body=$(echo "$resp" | sed '$d')       # all but last line
#           status=$(echo "$resp" | tail -n1)    # last line
          
#           # Try to parse JSON, but don‚Äôt exit if it fails
#           if echo "$body" | jq . > /dev/null 2>&1; then
#             echo "‚úîÔ∏è Parsed JSON:"
#             echo "$body" | jq .
#           else
#             echo "‚ö†Ô∏è Body is not JSON or empty"
#           fi

#           # Exit non-2xx
#           if [[ "$status" != 2* ]]; then
#             echo "‚ùå Health check failed (status $status)"
#             exit 1
#           fi

#       - name: üì¶ POST polling payload
#         if: env.JSON_PAYLOAD_PATH != 'empty'
#         run: |
#           echo "Sending JSON payload to API"

#           response=$(curl -s -X POST "$API_BASE/polling" -H "Authorization: Bearer $TOKEN"  -H "Content-Type: application/json"   --data-binary "@$JSON_PAYLOAD_PATH")

#           result_status=$(echo "$response" | jq -r '.status // empty')
#           message=$(echo "$response" | jq -r '.message // "No message provided"')

#           if [ "$result_status" != "passed" ]; then
#             echo -e " ‚ùå Validation failed: \n $message"
#             exit 1
#           fi

#           echo "‚úÖ $message"

name: final

on:
  pull_request_target:
    branches:
      - main
    types:
      - opened
      - synchronize

permissions:
  id-token: write
  contents: read

env:
  CLIENT_ID: da7fd62a-590e-4e7a-8525-55ea01ffb1ac
  API_BASE: https://sentinel-content-validationapi-prod-bvgsc3hjhyeqangg.canadacentral-01.azurewebsites.net/

jobs:
  pr-validate:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout PR code
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}

      - name: Get changed JSON files and contents for all types
        id: prepare_json_files
        run: |
          echo "üîç Collecting changed JSON files‚Ä¶"
          BASE="${{ github.event.pull_request.base.sha }}"
          HEAD="${{ github.event.pull_request.head.sha }}"
          mapfile -t files < <(git diff --name-only "$BASE" "$HEAD" | grep -Ei '\.json$')
          echo "‚Üí All .json files: ${files[*]:-<none>}"

          declare -A keywords=( ["poll"]="poll" ["definition"]="definition" ["dcr"]="dcr" ["_CL"]="_CL" )
          for key in "${!keywords[@]}"; do
            filtered=()
            for f in "${files[@]}"; do
              if [[ "$f" =~ ${keywords[$key]} ]]; then
                filtered+=("$f")
              fi
            done
            echo "‚Üí ${key^^} files: ${filtered[*]:-<none>}"
            if [ ${#filtered[@]} -eq 0 ]; then
              echo "JSON_${key^^}_PATH=empty" >> $GITHUB_ENV
              continue
            fi

            json_array="["
            for f in "${filtered[@]}"; do
              if jq -e . "$f" > /dev/null; then
                content=$(jq -c . "$f")
                json_array+="{\"filename\":\"$f\",\"content\":$content},"
              else
                echo "‚ùå Invalid JSON in $f"
                exit 1
              fi
            done
            json_array="${json_array%,}]"
            file_name="files_payload_${key}.json"
            echo "$json_array" > "$file_name"
            echo "JSON_${key^^}_PATH=$file_name" >> $GITHUB_ENV
          done

      - name: Request OIDC token from GitHub
        id: fetch_token
        run: |
          echo "üîê Fetching OIDC token‚Ä¶"
          raw=$(curl -s -H "Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=api://${CLIENT_ID}")
          token=$(echo "$raw" | jq -r .value)
          echo "‚úîÔ∏è Got token (length=${#token})"
          echo "TOKEN=$token" >> $GITHUB_ENV

      - name: üì° Health-check GET
        run: |
          echo "üöÄ Hitting $API_BASE‚Ä¶"
          resp=$(curl -s -w "\n%{http_code}" -H "Authorization: Bearer $TOKEN" "$API_BASE")
          body=$(echo "$resp" | sed '$d')
          status=$(echo "$resp" | tail -n1)
          if echo "$body" | jq . > /dev/null 2>&1; then
            echo "$body" | jq .
          else
            echo "‚ö†Ô∏è Body is not JSON or empty"
          fi
          if [[ "$status" != 2* ]]; then
            echo "‚ùå Health check failed (status $status)"
            exit 1
          fi

      - name: POST polling payload
        if: env.JSON_POLL_PATH != 'empty'
        run: |
          response=$(curl -s -X POST "$API_BASE/polling" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" --data-binary "@$JSON_POLL_PATH")
          result_status=$(echo "$response" | jq -r '.status // empty')
          message=$(echo "$response" | jq -r '.message // "No message provided"')
          if [ "$result_status" != "passed" ]; then
            echo -e " ‚ùå Validation failed: \n $message"
            exit 1
          fi
          echo "‚úÖ $message"

      - name: POST definition payload
        if: env.JSON_DEFINITION_PATH != 'empty'
        run: |
          response=$(curl -s -X POST "$API_BASE/definition" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" --data-binary "@$JSON_DEFINITION_PATH")
          result_status=$(echo "$response" | jq -r '.status // empty')
          message=$(echo "$response" | jq -r '.message // "No message provided"')
          if [ "$result_status" != "passed" ]; then
            echo -e " ‚ùå Validation failed: \n $message"
            exit 1
          fi
          echo "‚úÖ $message"

      - name: POST DCR payload
        if: env.JSON_DCR_PATH != 'empty'
        run: |
          response=$(curl -s -X POST "$API_BASE/dcr" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" --data-binary "@$JSON_DCR_PATH")
          result_status=$(echo "$response" | jq -r '.status // empty')
          message=$(echo "$response" | jq -r '.message // "No message provided"')
          if [ "$result_status" != "passed" ]; then
            echo -e " ‚ùå Validation failed: \n $message"
            exit 1
          fi
          echo "‚úÖ $message"

      - name: POST _CL payload
        if: env.JSON__CL_PATH != 'empty'
        run: |
          response=$(curl -s -X POST "$API_BASE/cl" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" --data-binary "@$JSON__CL_PATH")
          result_status=$(echo "$response" | jq -r '.status // empty')
          message=$(echo "$response" | jq -r '.message // "No message provided"')
          if [ "$result_status" != "passed" ]; then
            echo -e " ‚ùå Validation failed: \n $message"
            exit 1
          fi
          echo "‚úÖ $message"

# .github/workflows/pr-validate.yml
name: 🔐 PR Validation via OIDC (GET & POST)

on:
  pull_request_target:
    types: [opened, synchronize]

permissions:
  id-token: write    # enable OIDC token issuance
  contents: read     # allow checkout of code

env:
  CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  API_BASE: https://sentintel-content-dev-fue4ashcg9fnfge9.canadacentral-01.azurewebsites.net/   # 🔁 replace with your App Service base URL

jobs:
  pr-validate:
    runs-on: ubuntu-latest

    steps:
      # 1. Fetch OIDC token in trusted context
      - name: 🔐 Request OIDC token from GitHub
        id: oidc
        run: |
          echo "🌐 Fetching OIDC token for audience: api://${CLIENT_ID}"
          raw=$(curl -s \
            -H "Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=api://${CLIENT_ID}")
          echo "🔁 Token response: $raw"
          token=$(echo "$raw" | jq -r '.value')
          echo "✔️ Token length: ${#token}"
          echo "TOKEN=$token" >> $GITHUB_ENV

      # 2. Checkout the PR head (untrusted code)
      - name: 🔄 Checkout PR head
        uses: actions/checkout@v3
        with:
          repository: ${{ github.event.pull_request.head.repo.full_name }}
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      # 3. Send a simple GET request to verify connectivity
      - name: 📡 Send GET request to protected endpoint
        run: |
          echo "🚀 GET $API_BASE/"
          response=$(curl -s -H "Authorization: Bearer $TOKEN" "$API_BASE/")
          echo "🔍 GET response:"
          echo "$response" | jq . || true

      # 4. Collect changed JSON files and build payload
      - name: 📁 Collect changed JSON files
        id: prepare_json_files
        run: |
          echo "🔍 Finding changed JSON files..."
          BASE="origin/${{ github.event.pull_request.base.ref }}"
          HEAD="${{ github.event.pull_request.head.sha }}"
          echo "Base ref: $BASE"
          echo "Head SHA: $HEAD"

          mapfile -t files < <(git diff --name-only "$BASE" "$HEAD" | grep '\.json$')
          echo "🧾 Changed JSON files: ${files[*]:-<none>}"

          json_array="["
          for file in "${files[@]}"; do
            echo "📄 Processing $file"
            if [ -f "$file" ] && jq -e . "$file" > /dev/null 2>&1; then
              content=$(jq -c . < "$file")
              json_array+="{\"filename\":\"$file\",\"content\":$content},"
            else
              echo "❌ Skipping invalid or missing JSON: $file"
            fi
          done
          json_array="${json_array%,}]"
          echo "$json_array" > files_payload.json
          echo "✅ Payload written to files_payload.json"
          echo "JSON_PAYLOAD_PATH=files_payload.json" >> $GITHUB_ENV

      # 5. Send POST request with JSON payload
      - name: 🚀 Send POST request with JSON payload
        run: |
          echo "🚀 POST $API_BASE/"
          response=$(curl -s -w "\n%{http_code}" -X POST "$API_BASE/" \
            -H "Authorization: Bearer $TOKEN" \
            -H "Content-Type: application/json" \
            --data-binary "@$JSON_PAYLOAD_PATH")
          
          body=$(echo "$response" | head -n -1)
          status_code=$(echo "$response" | tail -n1)
          
          echo "🌐 HTTP status: $status_code"
          echo "🌐 Response body:"
          echo "$body" | jq . || true

          if [ "$status_code" -ne 200 ]; then
            echo "❌ POST failed (HTTP $status_code)"
            exit 1
          fi
          result_status=$(jq -r '.status' <<< "$body")
          result_message=$(jq -r '.message' <<< "$body")
          if [ "$result_status" != "passed" ]; then
            echo "❌ Validation failed: $result_message"
            exit 1
          fi
          echo "✅ Validation passed: $result_message"
